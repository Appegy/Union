# Union struct for C#
This package provides `UnionAttribute`, which can be used to generate a container struct that can hold one of several specified struct types. The generated struct can also implement specified in `ExposeAttribute` interfaces.
Key Features:
- UnionAttribute: Specifies that the container struct can hold only one of the specified struct types at a time.
- ExposeAttribute: Specifies that the container struct should implement the specified interfaces, delegating the implementation to the currently held struct.

## Usage
### Defining the Container Struct
Define the container struct using the `UnionAttribute` and `ExposeAttribute` attributes:
```csharp
[Union(typeof(VoidCell), typeof(EmptyCell), typeof(RegularCell))]
[Expose(typeof(IPuzzleCell), typeof(IMatchableCell), typeof(IMovableCell))]
public partial struct PuzzleCell
{
}
```
### Defining the Structs and Interface
Define the structs and the interface that the container struct will implement:
```csharp
public interface IPuzzleCell
{
    public short Id { get; }
}

public interface IMatchableCell
{
    public bool Matchable { get; }
}

public interface IMovableCell
{
    public bool Movable { get; }
}

public struct VoidCell : IPuzzleCell
{
    public short Id => -2;
    public bool Movable => false;
    public bool Matchable => false;
}

public struct EmptyCell : IPuzzleCell
{
    public short Id => -1;
    public bool Movable => false;
    public bool Matchable => false;
}

public struct RegularCell : IPuzzleCell
{
    public short Id { get; set; }
    public bool Movable => true;
    public bool Matchable => true;

    public RegularCell(short id)
    {
        Id = id;
    }
}
```
That is it. Generator will generate all necessary code.

### Using the Generated PuzzleCell Struct
#### Creating an Array of PuzzleCell and Adding Different Cell Types

```csharp
// Create an array of PuzzleCell
PuzzleCell[] puzzleCells = new PuzzleCell[3];

// Add different cell types to the array
puzzleCells[0] = new VoidCell();
puzzleCells[1] = new EmptyCell();
puzzleCells[2] = new RegularCell(42);

// Print information about the cells
foreach (var cell in puzzleCells)
{
    Debug.Log($"Type: {cell.Type}, Id: {cell.Id}, Movable: {cell.Movable}, Matchable: {cell.Matchable}");
}
```
#### Using switch to Check the Cell Type
```csharp
foreach (var cell in puzzleCells)
{
    switch (cell.Type)
    {
        case PuzzleCell.Kind.VoidCell:
            Debug.Log("This is a VoidCell");
            break;
        case PuzzleCell.Kind.EmptyCell:
            Debug.Log("This is an EmptyCell");
            break;
        case PuzzleCell.Kind.RegularCell:
            Debug.Log("This is a RegularCell with Id: " + cell.Id);
            break;
        default:
            throw new ArgumentOutOfRangeException();
    }
}
```
#### Using Implicit Conversion Operators
```csharp
// Implicit conversion from VoidCell to PuzzleCell
PuzzleCell voidCell = new VoidCell();

// Implicit conversion from PuzzleCell back to VoidCell
VoidCell extractedVoidCell = voidCell;
```
#### Working with Interfaces
```csharp
// Create a RegularCell
PuzzleCell regularCell = new RegularCell(42);

// Use the IPuzzleCell interface
IPuzzleCell puzzleCellInterface = regularCell;
Debug.Log($"IPuzzleCell Id: {puzzleCellInterface.Id}");

// Use the IMovableCell interface
IMovableCell movableCellInterface = regularCell;
Debug.Log($"IMovableCell Movable: {movableCellInterface.Movable}");

// Use the IMatchableCell interface
IMatchableCell matchableCellInterface = regularCell;
Debug.Log($"IMatchableCell Matchable: {matchableCellInterface.Matchable}");

Debug.Log($"Extracted VoidCell Id: {extractedVoidCell.Id}");
```

### Generated Code
The generator will produce the following code:
```csharp
// <auto-generated/>
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit, Pack = 1)]
public partial struct PuzzleCell : Appegy.Union.Cells.IPuzzleCell, Appegy.Union.Cells.IMatchableCell, Appegy.Union.Cells.IMovableCell
{
    [Serializable]
    public enum Kind : byte
    {
        VoidCell,
        EmptyCell,
        RegularCell,
    }
    
    [FieldOffset(0)]
    private Kind _type;
    
    [FieldOffset(1)]
    private Appegy.Union.Cells.VoidCell _voidCell;
    [FieldOffset(1)]
    private Appegy.Union.Cells.EmptyCell _emptyCell;
    [FieldOffset(1)]
    private Appegy.Union.Cells.RegularCell _regularCell;
    
    public Kind Type => _type;
    
    public Appegy.Union.Cells.VoidCell VoidCell
    {
        get => Type != Kind.VoidCell ? throw new Exception($"Can't get VoidCell because current type is '{Type}'.") : _voidCell;
        set
        {
            _type = Kind.VoidCell;
            _voidCell = value;
        }
    }
    
    public Appegy.Union.Cells.EmptyCell EmptyCell
    {
        get => Type != Kind.EmptyCell ? throw new Exception($"Can't get EmptyCell because current type is '{Type}'.") : _emptyCell;
        set
        {
            _type = Kind.EmptyCell;
            _emptyCell = value;
        }
    }
    
    public Appegy.Union.Cells.RegularCell RegularCell
    {
        get => Type != Kind.RegularCell ? throw new Exception($"Can't get RegularCell because current type is '{Type}'.") : _regularCell;
        set
        {
            _type = Kind.RegularCell;
            _regularCell = value;
        }
    }
    
    public PuzzleCell(Appegy.Union.Cells.VoidCell cell)
    {
        _type = Kind.VoidCell;
        _emptyCell = default;
        _regularCell = default;
        _voidCell = cell;
    }
    
    public PuzzleCell(Appegy.Union.Cells.EmptyCell cell)
    {
        _type = Kind.EmptyCell;
        _voidCell = default;
        _regularCell = default;
        _emptyCell = cell;
    }
    
    public PuzzleCell(Appegy.Union.Cells.RegularCell cell)
    {
        _type = Kind.RegularCell;
        _voidCell = default;
        _emptyCell = default;
        _regularCell = cell;
    }
    
    public short Id => _type switch
    {
        Kind.VoidCell => _voidCell.Id,
        Kind.EmptyCell => _emptyCell.Id,
        Kind.RegularCell => _regularCell.Id,
        _ => throw new ArgumentOutOfRangeException(nameof(Type), $"Unknown cell type: {_type}")
    };
    
    public bool Matchable => _type switch
    {
        Kind.VoidCell => _voidCell.Matchable,
        Kind.EmptyCell => _emptyCell.Matchable,
        Kind.RegularCell => _regularCell.Matchable,
        _ => throw new ArgumentOutOfRangeException(nameof(Type), $"Unknown cell type: {_type}")
    };
    
    public bool Movable => _type switch
    {
        Kind.VoidCell => _voidCell.Movable,
        Kind.EmptyCell => _emptyCell.Movable,
        Kind.RegularCell => _regularCell.Movable,
        _ => throw new ArgumentOutOfRangeException(nameof(Type), $"Unknown cell type: {_type}")
    };
    
    public static implicit operator Appegy.Union.Cells.VoidCell(PuzzleCell cell) => cell.VoidCell;
    public static implicit operator PuzzleCell(Appegy.Union.Cells.VoidCell cell) => new PuzzleCell(cell);
    
    public static implicit operator Appegy.Union.Cells.EmptyCell(PuzzleCell cell) => cell.EmptyCell;
    public static implicit operator PuzzleCell(Appegy.Union.Cells.EmptyCell cell) => new PuzzleCell(cell);
    
    public static implicit operator Appegy.Union.Cells.RegularCell(PuzzleCell cell) => cell.RegularCell;
    public static implicit operator PuzzleCell(Appegy.Union.Cells.RegularCell cell) => new PuzzleCell(cell);
}
```