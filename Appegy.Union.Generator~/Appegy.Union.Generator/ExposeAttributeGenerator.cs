using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Appegy.Union.Generator.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Appegy.Union.Generator.AttributesNames;

namespace Appegy.Union.Generator;

[Generator]
public class ExposeAttributeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var exposeSources = context
            .SyntaxProvider
            .ForAttributeWithMetadataName(
                ExposeAttributeName,
                predicate: static (syntax, _) => syntax is StructDeclarationSyntax,
                transform: static (ctx, _) =>
                {
                    var syntax = (StructDeclarationSyntax)ctx.TargetNode;
                    var attribute = ctx.Attributes.First();
                    var interfaces = attribute.GetTypesFromConstructor(TypeKind.Interface);
                    return (typeSyntax: syntax, interfaces);
                });

        var unionSources = context
            .SyntaxProvider
            .ForAttributeWithMetadataName(
                UnionAttributeName,
                predicate: static (syntax, _) => syntax is StructDeclarationSyntax,
                transform: static (ctx, _) =>
                {
                    var attribute = ctx.Attributes.First();
                    var types = attribute.GetTypesFromConstructor(TypeKind.Struct);
                    return types;
                });

        var sources = exposeSources.Combine(unionSources.Collect())
            .Select(static (input, _) =>
            {
                var ((syntax, interfaces), typesArray) = input;
                var types = ImmutableList.CreateBuilder<INamedTypeSymbol>();
                types.AddRange(typesArray.SelectMany(c => c));
                return (syntax, interfaces, types.ToImmutable());
            });

        context.RegisterSourceOutput(sources, static (ctx, input) =>
        {
            var (syntax, interfaces, types) = input;

            if (!syntax.Modifiers.Any(SyntaxKind.PartialKeyword))
            {
                return;
            }

            if (interfaces.Count == 0)
            {
                return;
            }

            using var memoryStream = new MemoryStream();
            using var streamWriter = new StreamWriter(memoryStream, Encoding.UTF8);
            using var codeWriter = new IndentedTextWriter(streamWriter, "    ");

            GenerateHeader(codeWriter, syntax);
            GenerateDeclaration(codeWriter, syntax, interfaces);
            GenerateImplementations(codeWriter, syntax, interfaces, types);
            GenerateStructureClose(codeWriter, syntax);

            streamWriter.Flush();
            ctx.AddSource($"{syntax.Identifier.Text}_Expose.g.cs", SourceText.From(memoryStream, Encoding.UTF8, canBeEmbedded: true));
        });
    }

    private static void GenerateHeader(IndentedTextWriter codeWriter, StructDeclarationSyntax syntax)
    {
        codeWriter.WriteLine("// <auto-generated/>");
        codeWriter.WriteLine("using System;");
        codeWriter.WriteLine();

        if (syntax.Parent is NamespaceDeclarationSyntax namespaceDeclaration)
        {
            codeWriter.Write("namespace ");
            codeWriter.WriteLine(namespaceDeclaration.Name);
            codeWriter.WriteLine('{');
            codeWriter.Indent++;
        }
    }

    private static void GenerateDeclaration(IndentedTextWriter codeWriter, StructDeclarationSyntax syntax, IImmutableList<INamedTypeSymbol> interfaces)
    {
        codeWriter.Write("public partial struct ");
        codeWriter.Write(syntax.Identifier.Text);

        codeWriter.WriteLine(" :");
        codeWriter.Indent++;
        for (var i = 0; i < interfaces.Count; i++)
        {
            var @interface = interfaces[i];
            codeWriter.Write("global::");
            codeWriter.Write(@interface.ToDisplayString());
            if (i != interfaces.Count - 1)
            {
                codeWriter.WriteLine(",");
            }
        }
        codeWriter.Indent--;

        codeWriter.WriteLine();
        codeWriter.WriteLine('{');
        codeWriter.Indent++;
    }

    private static void GenerateImplementations(IndentedTextWriter codeWriter, StructDeclarationSyntax syntax, IImmutableList<INamedTypeSymbol> interfaces, IImmutableList<INamedTypeSymbol> types)
    {
        for (var index = 0; index < interfaces.Count; index++)
        {
            var @interface = interfaces[index];
            codeWriter.Write("#region Implement ");
            codeWriter.WriteLine(@interface.Name);

            var members = @interface.GetMembers();
            for (var i = 0; i < members.Length; i++)
            {
                switch (members[i])
                {
                    case IPropertySymbol { IsIndexer: false, SetMethod: null } propertySymbol:
                        GeneratePropertyImplementation(codeWriter, propertySymbol, types);
                        break;
                    case IMethodSymbol { MethodKind: MethodKind.PropertyGet }:
                        break;
                    default:
                        codeWriter.WriteLine($"// Not supported part of interface: {members[i].GetType().Name} {members[i].Name}");
                        break;
                }
                if (i < members.Length - 1)
                {
                    codeWriter.WriteLine();
                }
            }

            codeWriter.Write("#endregion Implement ");
            codeWriter.WriteLine(@interface.Name);

            if (index < interfaces.Count - 1)
            {
                codeWriter.WriteLine();
            }
        }
    }

    private static void GeneratePropertyImplementation(IndentedTextWriter codeWriter, IPropertySymbol propertySymbol, IImmutableList<INamedTypeSymbol> types)
    {
        codeWriter.Write("public ");
        codeWriter.Write(propertySymbol.Type.ToDisplayString());
        codeWriter.Write(" ");
        codeWriter.Write(propertySymbol.Name);
        codeWriter.WriteLine(" => _type switch");
        codeWriter.WriteLine('{');
        codeWriter.Indent++;

        foreach (var type in types)
        {
            codeWriter.Write("Kind.");
            codeWriter.Write(type.Name);
            codeWriter.Write(" => _");
            codeWriter.Write(type.Name.ToCamelCase());
            codeWriter.Write(".");
            codeWriter.Write(propertySymbol.Name);
            codeWriter.WriteLine(",");
        }

        codeWriter.WriteLine("_ => throw new ArgumentOutOfRangeException(nameof(Type), $\"Unknown cell type: {_type}\")");
        codeWriter.Indent--;
        codeWriter.WriteLine("};");
    }

    private static void GenerateStructureClose(IndentedTextWriter codeWriter, StructDeclarationSyntax syntax)
    {
        codeWriter.Indent--;
        codeWriter.WriteLine('}');

        if (syntax.Parent is NamespaceDeclarationSyntax)
        {
            codeWriter.Indent--;
            codeWriter.WriteLine('}');
        }
    }
}